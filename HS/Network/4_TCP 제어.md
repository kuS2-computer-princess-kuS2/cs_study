### [흐름 제어]
* 송신 측의 속도가 수신측보다 빠를 경우, 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있음
  * 만약 손실된다면 불필요한 추가 패킷 전송이 발생
* 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법

** TCP 버퍼

    송신 측- 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송 
    
    수신 측- 도착한 TCP 세그먼트를 애플리케이션이 읽을 때까지 버퍼에 보관

    
#### 1. Stop and Wait
  ![image](https://github.com/kuS2-computer-princess-kuS2/cs_study/assets/81477543/06a01f11-83f2-4b57-94c6-0311b6fa97ec)

* 매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법
* 패킷을 하나씩 보내기 때문에 비효율적인 방법


#### 2. Sliding Window 
  ![image](https://github.com/kuS2-computer-princess-kuS2/cs_study/assets/81477543/4d69ac4b-190e-4dee-a025-f92bf3bb0279)

* 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법
* 윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답(ACK)이 오면 윈도우를 옆으로 옮겨 다음 패킷들을 전송


* 윈도우 크기: '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변함
  * 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보냄
 
* 재전송 : 송신 측은 일정 시간 동안 수신 측으로부터 확인 응답(ACK)을 받지 못하면, 패킷을 재전송함
* 재전송을 했는데, 패킷이 소실된 경우가 아니라 수신 측의 버퍼에 남는 공간 없는 경우?
  * 이를 해결하기 위해 송신 측은 해결 응답(ACK)을 보내면서 남은 버퍼의 크기(윈도우 크기)도 함께 보냄


___

### [혼잡 제어]
* 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못함
* 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 함
* **송신 측의 전송 속도를 조절**하여 예방할 수 있음



#### 1. AIMD(Additive Increse/Multicative Decrease)
![image](https://github.com/kuS2-computer-princess-kuS2/cs_study/assets/81477543/cc2a564f-029d-4687-9d85-eeb1cb74dcdf)

* 합 증가/곱 감소 방식
* 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송
* 전송에 실패하면 윈도우 크기를 반으로 줄임


* 단점: 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸림


#### 2. Slow Start (느린 시작)
* AIMD 방식과 달리 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식

 
* 장점: 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가하더라도, 시간이 지날수록 윈도우 크기가 점점 빠르게 증가


#### 3. 빠른 재전송
* 패킷을 받는 수신자에게 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우?
 * 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보냄
 * 이런 중복 ACK를 3개 받으면 재전송이 이루어짐

  
* 장점: 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있음


#### 4. 빠른 회복
* 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법
* 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작함

 
