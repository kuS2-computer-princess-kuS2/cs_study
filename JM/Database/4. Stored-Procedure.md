# 저장 프로시저

---

SP(Stored Procedure)은 **일련의 쿼리**를 마치 **하나의 함수**처럼 실행하기 위한 쿼리의 집합니다.

→ 특정 로직의 쿼리를 함수로 만든 것 

## SP를 사용하는 이유

1. **SQL server 성능 향상**
    - SP를 처음 실행하면 결과가 캐시(메모리)에 저장된다.
    - 이 후, 해당 SP를 실행하게 되면 캐시(메모리)에 있는 것을 가져와 사용해 실행속도가 빨라진다.
    - 즉, 일반 쿼리를 반복 실행하는 것 보다 SP를 사용하는게 성능적 측면에서 좋다.
2. **유지보수 및 재활용**
    - C#, Java 등에서 직접 SQL문을 호출하지 않고 저장 프로시저 이름을 호출해서 사용하는 경우가 있는데, 이때 수정 시 개발자는 SQL문이 아닌 **SP파일만 수정**하면 되기 때문에 유지보수 측면에서 유리하다.
    - SP는 생성 후 **언제든 실행이 가능**하여 재활용 측면에서 매우 좋다.
3. **보안 강화**
    - 테이블에 권한을 주는게 아닌 **SP에만 접근 권한** 주는 방식으로 보안을 강화할 수 있다.
    - 실제로 개발자에게는 테이블 접근은 위험하기에 SP 권한만 주는 방식을 많이 사용한다.
4. **네트워크 부하 감소** 
    - 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송될 경우 네트워크에 큰 부하가 발생한다.
    - SP를 이용하면 SP 이름, 매개변수등 몇글자만 전송하면 되기 때문에 부하를 크게 줄일 수 있다.

## 동작 방식

### 일반(SQL) 방식

일반적인 SQL → `구문분석` → `개체 이름 확인` → `사용권한 확인` → `최적화` → `컴파일 및 실행계획 등록(메모리(캐시))` → `실행` 

1. **구문분석** : 구문 자체에 오류가 없는지 분석하고, 오타가 있으면 에러메시지를 띄운다. 
2. **개체 이름 확인** : 구문에 입력한 테이블 이름이 현재 데이터베이스에 있는지 확인한다. 
    - `SELECT column FROM table;`
    - 테이블 이름을 확인하고 있다면 해당 컬럼이 있는지를 확인한다.
3. **사용권한 확인** : 해당 테이블에 현재 접근중인 사용자가 권한이 있는지 확인한다.
4. **최적화** : 해당 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 결정 → 인덱스에 따라 경로가 결정
5. **컴파일 및 실행계획 등록** : 최적화된 결과를 바탕으로 컴파일 및 실행 계획 등록 단계에서 해당 실해계획 결과를 메모리(캐시에) 등록한다.
6. 컴파일된 결과 **실행**

### 동일한 SQL문 실행

`메모리(캐시) 확인` → `실행` 

: 동일한 SQL문 실행 시 여러 과정이 생략되어 단순하게 동작한다. 

## 저장 프로시저 동작 방식

### 저장 프로시저 정의

CREATE PROCEDURE → `구문분석` →`지연된 이름 확인` → `시스템 테이블에 등록` → `생성 권한 확인`  → `시스템 테이블에 등록` 

1. **구문 분석** : SP에서 구문 오류가 있는지 파악
2. **지연된 이름 확인(deferred name resolution)**
    - SP의 특징 중 하나
    - 프로시저를 정의하는 시점에서 테이블과 같은 개체 존재 여부와 상관없이 정의가 가능하다.  → 테이블 존재 여부를 프로시저 실행 시점에서 확인하기 때문
3. **생성 권한 확인** : 사용자가 SP를 생성할 권한이 있는지 확인
4. **시스템 테이블 등록** : 저장 프로시저 이름과 코드가 관련 시스템 테이블에 등록되는 과정 

### 저장 프로시저 실행

SP 첫번째 실행 → `개체 이름 확인` → `사용권한 확인` → `최적화` → `컴파일 및 실행계획 등록(메모리(캐시))` → `실행` 

- 일반적인 쿼리를 수행하는 것과 비슷하고, 정의단계에서 구문분석이 끝나 구문분석은 진행하지 않은다.
- 정의 시 지연된 이름 확인에서 하지않은 개체의 유효 여부를 실행 시 진행한다.

### 저장 프로시저 동일한 실행

SP 두번째 실행 → `메모리(캐시) 확인` → `실행` 

- 메모리(캐시)에 있는 것을 재사용해 수행시간이 많이 단축된다.

## 차이점

```sql
SELECT * FROM userTbl WHERE name ='A';
SELECT * FROM userTbl WHERE name ='B';
SELECT * FROM userTbl WHERE name ='C';
```

- 일반 쿼리는 글자가 하나라도 다르면 다른 쿼리로 인식한다. 즉 위 세 쿼리를 모두 다른 것으로 인식한다.

```sql
CREATE PROC select_by_name
	@Name NVARCHAR(3)
AS
	SELECT * FROM userTbl WHERE name =@name;
```

```sql
EXEC select_by_name 'A';
EXEC select_by_name 'B';
EXEC select_by_name 'C';
```

- 이 경우는 A를 검색하는 과정에서만 최적화 및 컴파일을 수행하고 나머지(B,C)는 메모리(캐시)에 있는 것을 사용하게 된다.

## 문제점

- DB 확장 어려움
    - 서버의 수를 늘려야 할때 DB의 수를 늘리는 것이 어렵다.
- 데이터 분석의 어려움
    - 프로시저가 여러 곳에 사용되면 수정했을 때 영향의 분석이 어렵다
    - 배포, 버전 관리 등에 대한 이력 관리가 힘들다.
    - APP에서 SP를 호출하여 사용하는 경우 문제가 생겨도 해당 이슈에 대한 추적이 힘들다.
- 성능
    - SP 실행 시 최적화 단계에서 인덱스 사용 여부를 결정한다.
    - 이때, 인덱스를 사용한다고 항상 수행결과가 빨라지지 않는다. 만약 다량의 데이터를 가져온다면 성능은 더 나빠질 것이다.
    - 첫번째 수행 시 최적화가 이루어져 인덱스 사용여부가 결정되는데, 두번째 수행시 많은 건 수의 데이터를 가져온다면 성능에 크게 문제가 될 것이다.
    - 이를 방지 하기 위해서는 저장 프로시저를 다시 컴파일 해주어야한다.

참고

https://pangtrue.tistory.com/196

https://devkingdom.tistory.com/323

[https://velog.io/@sweet_sumin/저장-프로시저-Stored-Procedure](https://velog.io/@sweet_sumin/%EC%A0%80%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80-Stored-Procedure)
