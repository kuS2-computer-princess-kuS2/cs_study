# TCP/IP 흐름제어

---

송신측과 수신측의 **데이터 처리 속도 차이를 해결**하기 위한 기법

- 송신측의 속도가 수신측의 데이터 처리 속도보다 빠를 경우 문제가 생긴다.
- 수신측에서 제한된 용량을 초과한 이후 도착하는 데이터는 손실될 수 있다. → 데이터 전송량을 조절해야한다 → 흐름제어
- 해결 방법
    - **Stop and Wait** : 매번 전송한 패킷에 대한 확인 응답을 받아야만 다음 패킷을 전송하는 방법
        - ex) 1번 패킷 전송 → 1번 패킷 확인 → 2번 패킷 전송 → 2번 패킷 확인 ..
        - 패킷을 하나씩 보내기 때문에 비효율적이다
    - **Sliding Window** : 수신측에서 설정한 윈도우 크기만큼 송신측에서 **확인 응답없이** 세그먼트 전송할 수 있게해 데이터 흐름을 동적으로 조절하는 기법
        - 윈도우 : TCP/IP를 사용하는 호스트들은 송신을 위한 것과 수신하기 위한 2개의 윈도우를 가지고 있다.
        - 윈도우에 포함된 모든 패킷을 전송하고, 패킷 전달이 확인(ACK)되는대로 다음 패킷을 전송한다.
        - ex ) 윈도우 크기가 7이면 보낼 패킷은 0-6, 차례대로 보내다가 응답을 하나 받으면(1까지 보냈다 가정) 패킷을 2-8(ACK 하나니까 5)로 옮기고 다시 차례대로 보낸다

# TCP/IP 혼잡제어

---

송신측의 데이터 전달과 네트워크 **데이터 처리 속도 차이를 해결**하기 위한 기법 

- 송신측의 데이터는 대형 네트워크를 통해 전달되는데, 하나의 라우터에 데이터가 몰리면 모두 처리할 수 없다 → 재전송으로 인한 혼잡 → 혼잡을 피하기 위해 **데이터 전송속도 강제로 줄이기** : 혼잡제어
- 해결방법
    - AIMD(Additive Increase / Multiplicative Decrease)
        - 처음 패킷을 하나 보내고 문제없이 도착하면 **윈도우 크기를 1씩 증가**시키며 전송하는 방법
        - 패킷 전송을 실패하거나 일정시간을 넘으면 속도를 절반으로 줄인다.
        - 시간이 흐를수록 여러 호스트가 공평하게 사용할 수 있는 특징
        - 초기에는 네트워크의 높은 대역폭을 사용하지못해 오랜 시간이 걸리고 혼잡해지는 것을 미리 감지하지 못하는 문제가 있다.
    - Slow Start : 느린 시작
        - AIMD와 비슷하지만, **각각**의 ACK **패킷마다 윈도우 크기를 1씩 늘려준다** → 윈도우 크기가 2배 → 지수 함수 꼴로 증가
        - 혼잡 현상이 발생하면 윈도우크기를 1로 떨어뜨린다.
        - 혼잡 현상이 한번 발생하면 네트워크의 수용량을 예상할 수 있다. → 이를 바탕으로 절반 이후로는 완만하게 1씩 증가시킨다
    - Fast Retransmit : 빠른 재전송
        - TCP 혼잡 조절에 추가된 정책
        - 수신측에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보낸다.
        - 순서대로 도착한 마지막 패킷의 다음 패킷 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되면 순번이 중복된 ACK 패킷을 받게 된다. → 이를 **감지해 재전송**
            - 중복된 패킷 3개를 받으면 재전송
    - Fast Recovery : 빠른 회복
        - **혼잡한 상태**가 되면 **윈도우 크기를 반**으로 줄이는 방법
